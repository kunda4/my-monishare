import { ApiProperty, OmitType, PartialType } from '@nestjs/swagger'
import { IsInt, IsNotEmpty, IsPositive, IsString, IsUrl } from 'class-validator'
import { Nullable } from 'class-validator-extended'
import { type Writable } from 'type-fest'

import { type CarType, type CarTypeID } from '../../application'
import { validate } from '../../util'

// This is a "Data Transfer Object" (see https://en.wikipedia.org/wiki/Data_transfer_object) for a car type. Its
// purpose is to encapsulate and validate request and/or response data. They are scoped to controllers and should
// not be used anywhere else - so don't pass them to services or return them from there.

export class CarTypeDTO {
  // We mark all properties as "readonly" so we can pretend the entire object is immutable:
  //   https://en.wikipedia.org/wiki/Immutable_object
  //
  // The main benefit here is that immutable objects are easier to reason about. You can pass them around and use them
  // as parameters without having to worry that someone somewhere modifies them. Because we validate objects upon
  // creation, this also implies that every instance of such an object will always be valid, which is an extremely
  // useful property.
  //
  // Note that "readonly" is a TypeScript feature, it doesn't actually prevent you from changing those properties, it
  // will only create a compiler error which you can ignore if you really want to.

  @ApiProperty({
    description: 'The id of the car type.',
    type: 'integer',
    minimum: 1,
    example: 23,
    readOnly: true,
  })
  @IsInt()
  @IsPositive()
  public readonly id!: CarTypeID

  @ApiProperty({
    description: 'The name of this car type.',
    minLength: 1,
  })
  @IsString()
  @IsNotEmpty()
  public readonly name!: string

  @ApiProperty({
    description: 'The image url for this car type.',
    type: String,
    format: 'uri',
    nullable: true,
  })
  @Nullable()
  @IsUrl()
  public readonly imageUrl!: string | null

  // DTOs come in two flavors: "request DTOs" (which are sent from the client, typically as the body of a POST, PUT or
  // PATCH request) and "response DTOs" (sent from the server in the response body). Some DTOs are both at the same time.
  //
  // Request DTOs are created automatically by Nest.js via a Validation Pipe, see
  //   https://docs.nestjs.com/techniques/validation#transform-payload-objects
  // This transformation requires a parameterless constructor, which is why you don't see one here.
  //
  // In some cases, the request- and response-flavor of a DTO differ very slightly. For instance, when you create a user
  // you don't send an ID to the server because it is generated by the database, while the response will contain an ID -
  // but the rest of the DTO is identical.
  // In these situations you can use so-called "Partial Types" to omit (or pick) selected properties while keeping the
  // rest of the DTO. See https://docs.nestjs.com/openapi/mapped-types#partial for more details.

  // This CarTypeDTO is being used both as a request *and* a response DTO, so we leave the constructor empty for the
  // reasons explained above. You can of course still create instances via "new CarTypeDTO()" but you would get an empty
  // instance and none of the defined validations would be applied, so that is error-prone. As a workaround, we provide
  // this static method to create fully validated instances of this class.
  public static create(data: {
    id: CarTypeID
    name: string
    imageUrl: string | null
  }): CarTypeDTO {
    const instance = new CarTypeDTO() as Writable<CarTypeDTO>

    instance.id = data.id
    instance.name = data.name
    instance.imageUrl = data.imageUrl

    return validate(instance)
  }

  // For convenience, we provide a factory method here to map a domain model to its corresponding DTO. In this
  // particular case it's fairy pointless, but you can easily imagine cases where this conversion is a bit more involved
  // (for instance if your domain model has properties that are not directly serializable out-of-the-box such as Maps or
  // Sets).
  public static fromModel(carType: CarType): CarTypeDTO {
    return CarTypeDTO.create(carType)
  }
}

// As explained above, we reuse the CarTypeDTO here but drop the 'id' when creating a new car type.
export class CreateCarTypeDTO extends OmitType(CarTypeDTO, ['id'] as const) {}

// When updating a car type, we don't want an id (because that is not an updatable property, it will be provided as an
// URL parameter). We also make all properties optional so that you can, for example, update the name of a car type
// independently of the imageUrl.
export class PatchCarTypeDTO extends PartialType(
  OmitType(CarTypeDTO, ['id'] as const),
) {}
